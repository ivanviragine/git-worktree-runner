#!/usr/bin/env bash
# Generate shell completion files from adapter registries and config key maps.
# Sources of truth: _EDITOR_REGISTRY, _AI_REGISTRY (lib/adapters.sh), _CFG_KEY_MAP (lib/config.sh)
#
# Usage:
#   ./scripts/generate-completions.sh          # Regenerate all completion files
#   ./scripts/generate-completions.sh --check  # Verify files are up to date (for CI)
set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# ── Data extraction ──────────────────────────────────────────────────────────

# Extract adapter names from a registry variable (pipe-delimited, name is first field)
_names_from_registry() {
  local registry="$1"
  local line
  while IFS= read -r line; do
    [ -z "$line" ] && continue
    printf "%s\n" "${line%%|*}"
  done <<EOF
$registry
EOF
}

# Source just the registry variables (no side effects — we only need the data)
# Stub out all functions these files define to avoid dependency issues
log_error() { :; }; log_info() { :; }; log_warn() { :; }; log_step() { :; }
cfg_default() { :; }; cfg_get() { :; }; cfg_get_all() { :; }; cfg_get_file() { :; }
cfg_map_to_file_key() { :; }; cfg_map_from_file_key() { :; }; _cfg_is_known_key() { :; }
show_command_help() { :; }; _cfg_editor_default() { echo "none"; }; _cfg_ai_default() { echo "none"; }
command() { :; }; _gtrconfig_path() { :; }
discover_repo_root() { :; }; resolve_base_dir() { :; }

# shellcheck disable=SC1091
. "$SCRIPT_DIR/lib/adapters.sh" 2>/dev/null || true
# shellcheck disable=SC1091
. "$SCRIPT_DIR/lib/config.sh" 2>/dev/null || true

# Collect editor names: registry + custom files, sorted, deduplicated
get_editor_names() {
  local names
  names=$(_names_from_registry "$_EDITOR_REGISTRY")

  # Add custom adapter file names
  local f name
  for f in "$SCRIPT_DIR"/adapters/editor/*.sh; do
    [ -f "$f" ] || continue
    name=$(basename "$f" .sh)
    names="$names"$'\n'"$name"
  done

  # Sort, deduplicate, add "none" sentinel
  printf "%s\nnone\n" "$names" | sort -u | tr '\n' ' ' | sed 's/ *$//'
}

# Collect AI tool names: registry + custom files, sorted, deduplicated
get_ai_names() {
  local names
  names=$(_names_from_registry "$_AI_REGISTRY")

  local f name
  for f in "$SCRIPT_DIR"/adapters/ai/*.sh; do
    [ -f "$f" ] || continue
    name=$(basename "$f" .sh)
    names="$names"$'\n'"$name"
  done

  printf "%s\nnone\n" "$names" | sort -u | tr '\n' ' ' | sed 's/ *$//'
}

# Collect config keys from _CFG_KEY_MAP (left side of each pair)
get_config_keys() {
  local pair keys=""
  for pair in "${_CFG_KEY_MAP[@]}"; do
    keys="$keys ${pair%%|*}"
  done
  echo "$keys" | xargs  # trim whitespace
}

# ── Resolve data ─────────────────────────────────────────────────────────────

EDITORS=$(get_editor_names)
AI_TOOLS=$(get_ai_names)
CONFIG_KEYS=$(get_config_keys)

# ── Generators ───────────────────────────────────────────────────────────────

generate_bash() {
  cat <<'HEADER'
#!/usr/bin/env bash
# AUTO-GENERATED by scripts/generate-completions.sh — DO NOT EDIT MANUALLY
# Re-generate with: ./scripts/generate-completions.sh
#
# Bash completion for git gtr
#
# Prerequisites:
#   - bash-completion v2+ must be installed
#   - Git's bash completion must be enabled
#
# This completion integrates with git's completion system by defining a _git_<subcommand>
# function, which git's completion framework automatically discovers and calls when
# completing "git gtr ..." commands.
#
# Installation:
#   Add to your ~/.bashrc:
#     source /path/to/git-worktree-runner/completions/gtr.bash

_git_gtr() {
  local cur prev words cword
  _init_completion || return

  # words array for git subcommand: [git, gtr, <actual_command>, ...]
  # cword is the index of current word being completed

  # If we're completing the first argument after 'git gtr'
  if [ "$cword" -eq 2 ]; then
    COMPREPLY=($(compgen -W "new go run copy editor ai rm mv rename ls list clean doctor adapter config completion init help version" -- "$cur"))
    return 0
  fi

  local cmd="${words[2]}"

  # Commands that take branch names or '1' for main repo
  case "$cmd" in
    go|run|rm|mv|rename)
      if [ "$cword" -eq 3 ]; then
        # Complete with branch names and special ID '1' for main repo
        local branches all_options
        branches=$(git branch --format='%(refname:short)' 2>/dev/null || true)
        all_options="1 $branches"
        COMPREPLY=($(compgen -W "$all_options" -- "$cur"))
      elif [[ "$cur" == -* ]]; then
        case "$cmd" in
          rm)
            COMPREPLY=($(compgen -W "--delete-branch --force --yes" -- "$cur"))
            ;;
          mv|rename)
            COMPREPLY=($(compgen -W "--force --yes" -- "$cur"))
            ;;
        esac
      fi
      ;;
    editor)
      if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W "--editor" -- "$cur"))
      elif [ "$prev" = "--editor" ]; then
HEADER
  printf '        COMPREPLY=($(compgen -W "%s" -- "$cur"))\n' "$EDITORS"
  cat <<'MIDDLE1'
      else
        local branches all_options
        branches=$(git branch --format='%(refname:short)' 2>/dev/null || true)
        all_options="1 $branches"
        COMPREPLY=($(compgen -W "$all_options" -- "$cur"))
      fi
      ;;
    ai)
      if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W "--ai" -- "$cur"))
      elif [ "$prev" = "--ai" ]; then
MIDDLE1
  printf '        COMPREPLY=($(compgen -W "%s" -- "$cur"))\n' "$AI_TOOLS"
  cat <<'MIDDLE2'
      else
        local branches all_options
        branches=$(git branch --format='%(refname:short)' 2>/dev/null || true)
        all_options="1 $branches"
        COMPREPLY=($(compgen -W "$all_options" -- "$cur"))
      fi
      ;;
    ls|list)
      if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W "--porcelain" -- "$cur"))
      fi
      ;;
    clean)
      if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W "--merged --yes -y --dry-run -n" -- "$cur"))
      fi
      ;;
    copy)
      if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W "-n --dry-run -a --all --from" -- "$cur"))
      else
        # Complete with branch names and special ID '1' for main repo
        local branches all_options
        branches=$(git branch --format='%(refname:short)' 2>/dev/null || true)
        all_options="1 $branches"
        COMPREPLY=($(compgen -W "$all_options" -- "$cur"))
      fi
      ;;
    new)
      # Complete flags
      if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W "--from --from-current --track --no-copy --no-fetch --no-hooks --force --name --folder --yes --editor -e --ai -a" -- "$cur"))
      elif [ "$prev" = "--track" ]; then
        COMPREPLY=($(compgen -W "auto remote local none" -- "$cur"))
      fi
      ;;
    completion)
      # Complete with shell names
      if [ "$cword" -eq 3 ]; then
        COMPREPLY=($(compgen -W "bash zsh fish" -- "$cur"))
      fi
      ;;
    init)
      if [ "$cword" -eq 3 ]; then
        COMPREPLY=($(compgen -W "bash zsh fish" -- "$cur"))
      elif [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W "--as" -- "$cur"))
      fi
      ;;
    config)
      # Find action by scanning all config args (handles flexible flag positioning)
      local config_action=""
      local i
      for (( i=3; i < cword; i++ )); do
        case "${words[i]}" in
          list|get|set|add|unset) config_action="${words[i]}" ;;
        esac
      done

      if [ -z "$config_action" ]; then
        # Still need to complete action or scope
        COMPREPLY=($(compgen -W "list get set add unset --local --global --system" -- "$cur"))
      else
        # Have action, complete based on it
        case "$config_action" in
          list|get)
            # Read operations support all scopes including --system
            if [[ "$cur" == -* ]]; then
              COMPREPLY=($(compgen -W "--local --global --system" -- "$cur"))
            else
MIDDLE2
  printf '              COMPREPLY=($(compgen -W "%s" -- "$cur"))\n' "$CONFIG_KEYS"
  cat <<'MIDDLE3'
            fi
            ;;
          set|add|unset)
            # Write operations only support --local and --global (--system requires root)
            if [[ "$cur" == -* ]]; then
              COMPREPLY=($(compgen -W "--local --global" -- "$cur"))
            else
MIDDLE3
  printf '              COMPREPLY=($(compgen -W "%s" -- "$cur"))\n' "$CONFIG_KEYS"
  cat <<'FOOTER'
            fi
            ;;
        esac
      fi
      ;;
  esac
}
FOOTER
}

generate_zsh() {
  cat <<'HEADER'
#compdef _git-gtr git-gtr gtr
# AUTO-GENERATED by scripts/generate-completions.sh — DO NOT EDIT MANUALLY
# Re-generate with: ./scripts/generate-completions.sh
#
# Zsh completion for git gtr (Git Worktree Runner)
#
# SETUP: For completions to work with `git gtr`, add this to ~/.zshrc
# BEFORE any existing compinit call:
#
#   eval "$(git gtr completion zsh)"
#
# This registers gtr as a git subcommand and sets up the completion path.
# Run `git gtr completion --help` for more details.
#
# WHY: Zsh needs to know `gtr` is a valid git subcommand BEFORE completion
# triggers. The zstyle registration below only runs when this file is loaded,
# but autoloading happens AFTER completion - a timing issue. The `completion`
# command outputs the zstyle before compinit, solving this.

_git-gtr() {
  # Normalize invocation so we always see: [git, gtr, <command>, ...]
  # Handles: `git gtr`, `gtr`, and `git-gtr` invocations
  if [[ $words[1] != git ]]; then
    # Handle both `gtr ...` and `git-gtr ...`
    words=(git gtr "${words[@]:1}")
    (( CURRENT += 1 ))
  fi

  local -a commands
  commands=(
    'new:Create a new worktree'
    'go:Navigate to worktree'
    'run:Execute command in worktree'
    'copy:Copy files between worktrees'
    'rm:Remove worktree(s)'
    'mv:Rename worktree and branch'
    'rename:Rename worktree and branch'
    'editor:Open worktree in editor'
    'ai:Start AI coding tool'
    'ls:List all worktrees'
    'list:List all worktrees'
    'clean:Remove stale worktrees'
    'doctor:Health check'
    'adapter:List available adapters'
    'config:Manage configuration'
    'completion:Generate shell completions'
    'init:Generate shell integration for cd support'
    'version:Show version'
    'help:Show help'
  )

  local -a branches all_options
  # Get branch names
  branches=(${(f)"$(git branch --format='%(refname:short)' 2>/dev/null)"})
  # Add special ID '1' for main repo
  all_options=("1" "${branches[@]}")

  # Early handler for `new` command - handle all positions
  if (( CURRENT >= 4 )) && [[ $words[3] == new ]]; then
    _arguments \
      '1:branch name:' \
      '--from[Base ref]:ref:' \
      '--from-current[Create from current branch]' \
      '--track[Track mode]:mode:(auto remote local none)' \
      '--no-copy[Skip file copying]' \
      '--no-fetch[Skip git fetch]' \
      '--no-hooks[Skip post-create hooks]' \
      '--force[Allow same branch in multiple worktrees]' \
      '--name[Custom folder name suffix]:name:' \
      '--folder[Custom folder name (replaces default)]:folder:' \
      '--yes[Non-interactive mode]' \
      '--editor[Open in editor after creation]' \
      '-e[Open in editor after creation]' \
      '--ai[Start AI tool after creation]' \
      '-a[Start AI tool after creation]'
    return
  fi

  # Early handler for `clean` command
  if (( CURRENT >= 4 )) && [[ $words[3] == clean ]]; then
    _arguments \
      '--merged[Remove worktrees with merged PRs/MRs]' \
      '--yes[Skip confirmation prompts]' \
      '-y[Skip confirmation prompts]' \
      '--dry-run[Show what would be removed]' \
      '-n[Show what would be removed]'
    return
  fi

  # Early handler for `list/ls` command - add --porcelain
  if (( CURRENT >= 4 )) && [[ $words[3] == (list|ls) ]]; then
    _arguments '--porcelain[Machine-readable output]'
    return
  fi

  # Complete the gtr subcommand (new, go, editor, etc.)
  if (( CURRENT == 3 )); then
    _describe 'commands' commands
  # Complete arguments to the subcommand
  elif (( CURRENT == 4 )); then
    case "$words[3]" in
      go|run|rm|mv|rename|copy)
        _describe 'branch names' all_options
        ;;
      editor)
        _describe 'branch names' all_options
        ;;
      ai)
        _describe 'branch names' all_options
        ;;
      config)
        # Complete action or scope flags
        _values 'config action' list get set add unset --local --global --system
        ;;
      completion)
        # Complete shell names
        _values 'shell' bash zsh fish
        ;;
      init)
        # Complete shell names
        _values 'shell' bash zsh fish
        ;;
    esac
  # Complete subsequent arguments
  elif (( CURRENT >= 5 )); then
    case "$words[3]" in
      editor)
HEADER
  printf "        _arguments '--editor[Editor to use]:editor:(%s)'\n" "$EDITORS"
  cat <<'MIDDLE1'
        ;;
      ai)
MIDDLE1
  printf "        _arguments '--ai[AI tool to use]:tool:(%s)'\n" "$AI_TOOLS"
  cat <<'MIDDLE2'
        ;;
      rm)
        _arguments \
          '--delete-branch[Delete branch]' \
          '--force[Force removal even if dirty]' \
          '--yes[Non-interactive mode]'
        ;;
      mv|rename)
        _arguments \
          '--force[Force move even if locked]' \
          '--yes[Skip confirmation]'
        ;;
      copy)
        _arguments \
          '-n[Dry-run preview]' \
          '--dry-run[Preview without copying]' \
          '-a[Copy to all worktrees]' \
          '--all[Copy to all worktrees]' \
          '--from[Source worktree]:source:->worktrees' \
          '*:target:->worktrees'
        case "$state" in
          worktrees) _describe 'branch names' all_options ;;
        esac
        ;;
      init)
        _arguments '--as[Custom function name]:name:'
        ;;
      config)
        # Find action by scanning all config args (handles flexible flag positioning)
        # Use offset 3 to start from words[4] (first arg after 'config')
        # Zsh uses 0-based offset: ${array[@]:3} = elements starting from 4th position
        local config_action=""
        local arg
        for arg in "${words[@]:3}"; do
          case "$arg" in
            list|get|set|add|unset)
              [[ -z "$config_action" ]] && config_action="$arg"
              ;;
          esac
        done

        if [[ -z "$config_action" ]]; then
          # Still need action or scope
          _values 'config action' list get set add unset --local --global --system
        else
          case "$config_action" in
            list|get)
              # Read operations support all scopes including --system
              _arguments \
                '--local[Use local git config]' \
                '--global[Use global git config]' \
                '--system[Use system git config]' \
MIDDLE2
  printf "                '*:config key:(%s)'\n" "$CONFIG_KEYS"
  cat <<'MIDDLE3'
              ;;
            set|add|unset)
              # Write operations only support --local and --global
              # (--system may require root or appropriate file permissions)
              _arguments \
                '--local[Use local git config]' \
                '--global[Use global git config]' \
MIDDLE3
  printf "                '*:config key:(%s)'\n" "$CONFIG_KEYS"
  cat <<'FOOTER'
              ;;
          esac
        fi
        ;;
    esac
  fi
}

_git-gtr "$@"
FOOTER
}

generate_fish() {
  cat <<'HEADER'
# AUTO-GENERATED by scripts/generate-completions.sh — DO NOT EDIT MANUALLY
# Re-generate with: ./scripts/generate-completions.sh
#
# Fish completion for git gtr
#
# This completion integrates with fish's completion system by registering completions
# for the "git" command with custom predicates that detect "git gtr" usage.
#
# Installation:
#   Symlink to fish's completions directory:
#     ln -s /path/to/git-worktree-runner/completions/git-gtr.fish ~/.config/fish/completions/
#   Then reload fish:
#     exec fish

# Helper function to check if we're in 'git gtr' context
function __fish_git_gtr_needs_command
  set -l cmd (commandline -opc)
  if [ (count $cmd) -eq 2 -a "$cmd[1]" = "git" -a "$cmd[2]" = "gtr" ]
    return 0
  end
  return 1
end

function __fish_git_gtr_using_command
  set -l cmd (commandline -opc)
  if [ (count $cmd) -ge 3 -a "$cmd[1]" = "git" -a "$cmd[2]" = "gtr" ]
    for i in $argv
      if [ "$cmd[3]" = "$i" ]
        return 0
      end
    end
  end
  return 1
end

# Commands
complete -f -c git -n '__fish_git_gtr_needs_command' -a new -d 'Create a new worktree'
complete -f -c git -n '__fish_git_gtr_needs_command' -a go -d 'Navigate to worktree'
complete -f -c git -n '__fish_git_gtr_needs_command' -a run -d 'Execute command in worktree'
complete -f -c git -n '__fish_git_gtr_needs_command' -a rm -d 'Remove worktree(s)'
complete -f -c git -n '__fish_git_gtr_needs_command' -a mv -d 'Rename worktree and branch'
complete -f -c git -n '__fish_git_gtr_needs_command' -a rename -d 'Rename worktree and branch'
complete -f -c git -n '__fish_git_gtr_needs_command' -a copy -d 'Copy files between worktrees'
complete -f -c git -n '__fish_git_gtr_needs_command' -a editor -d 'Open worktree in editor'
complete -f -c git -n '__fish_git_gtr_needs_command' -a ai -d 'Start AI coding tool'
complete -f -c git -n '__fish_git_gtr_needs_command' -a ls -d 'List all worktrees'
complete -f -c git -n '__fish_git_gtr_needs_command' -a list -d 'List all worktrees'
complete -f -c git -n '__fish_git_gtr_needs_command' -a clean -d 'Remove stale worktrees'
complete -f -c git -n '__fish_git_gtr_needs_command' -a doctor -d 'Health check'
complete -f -c git -n '__fish_git_gtr_needs_command' -a adapter -d 'List available adapters'
complete -f -c git -n '__fish_git_gtr_needs_command' -a config -d 'Manage configuration'
complete -f -c git -n '__fish_git_gtr_needs_command' -a completion -d 'Generate shell completions'
complete -f -c git -n '__fish_git_gtr_using_command completion' -a 'bash zsh fish' -d 'Shell type'
complete -f -c git -n '__fish_git_gtr_needs_command' -a init -d 'Generate shell integration for cd support'
complete -f -c git -n '__fish_git_gtr_using_command init' -a 'bash zsh fish' -d 'Shell type'
complete -c git -n '__fish_git_gtr_using_command init' -l as -d 'Custom function name' -r
complete -f -c git -n '__fish_git_gtr_needs_command' -a version -d 'Show version'
complete -f -c git -n '__fish_git_gtr_needs_command' -a help -d 'Show help'

# New command options
complete -c git -n '__fish_git_gtr_using_command new' -l from -d 'Base ref' -r
complete -c git -n '__fish_git_gtr_using_command new' -l from-current -d 'Create from current branch'
complete -c git -n '__fish_git_gtr_using_command new' -l track -d 'Track mode' -r -a 'auto remote local none'
complete -c git -n '__fish_git_gtr_using_command new' -l no-copy -d 'Skip file copying'
complete -c git -n '__fish_git_gtr_using_command new' -l no-fetch -d 'Skip git fetch'
complete -c git -n '__fish_git_gtr_using_command new' -l no-hooks -d 'Skip post-create hooks'
complete -c git -n '__fish_git_gtr_using_command new' -l force -d 'Allow same branch in multiple worktrees'
complete -c git -n '__fish_git_gtr_using_command new' -l name -d 'Custom folder name suffix' -r
complete -c git -n '__fish_git_gtr_using_command new' -l folder -d 'Custom folder name (replaces default)' -r
complete -c git -n '__fish_git_gtr_using_command new' -l yes -d 'Non-interactive mode'
complete -c git -n '__fish_git_gtr_using_command new' -s e -l editor -d 'Open in editor after creation'
complete -c git -n '__fish_git_gtr_using_command new' -s a -l ai -d 'Start AI tool after creation'

# Remove command options
complete -c git -n '__fish_git_gtr_using_command rm' -l delete-branch -d 'Delete branch'
complete -c git -n '__fish_git_gtr_using_command rm' -l force -d 'Force removal even if dirty'
complete -c git -n '__fish_git_gtr_using_command rm' -l yes -d 'Non-interactive mode'

# Rename command options
complete -c git -n '__fish_git_gtr_using_command mv' -l force -d 'Force move even if locked'
complete -c git -n '__fish_git_gtr_using_command mv' -l yes -d 'Skip confirmation'
complete -c git -n '__fish_git_gtr_using_command rename' -l force -d 'Force move even if locked'
complete -c git -n '__fish_git_gtr_using_command rename' -l yes -d 'Skip confirmation'

# Copy command options
complete -c git -n '__fish_git_gtr_using_command copy' -s n -l dry-run -d 'Preview without copying'
complete -c git -n '__fish_git_gtr_using_command copy' -s a -l all -d 'Copy to all worktrees'
complete -c git -n '__fish_git_gtr_using_command copy' -l from -d 'Source worktree' -r

# List command options
complete -c git -n '__fish_git_gtr_using_command list' -l porcelain -d 'Machine-readable output'
complete -c git -n '__fish_git_gtr_using_command ls' -l porcelain -d 'Machine-readable output'

# Editor command options
HEADER
  printf "complete -c git -n '__fish_git_gtr_using_command editor' -l editor -d 'Editor to use' -r -a '%s'\n" "$EDITORS"
  cat <<'MIDDLE1'

# AI command options
MIDDLE1
  printf "complete -c git -n '__fish_git_gtr_using_command ai' -l ai -d 'AI tool to use' -r -a '%s'\n" "$AI_TOOLS"
  cat <<'MIDDLE2'

# Clean command options
complete -c git -n '__fish_git_gtr_using_command clean' -l merged -d 'Remove worktrees with merged PRs/MRs'
complete -c git -n '__fish_git_gtr_using_command clean' -l yes -d 'Skip confirmation prompts'
complete -c git -n '__fish_git_gtr_using_command clean' -s y -d 'Skip confirmation prompts'
complete -c git -n '__fish_git_gtr_using_command clean' -l dry-run -d 'Show what would be removed'
complete -c git -n '__fish_git_gtr_using_command clean' -s n -d 'Show what would be removed'

# Config command
complete -f -c git -n '__fish_git_gtr_using_command config' -a 'list get set add unset'

# Helper to check if config action is a read operation (list or get)
function __fish_git_gtr_config_is_read
  set -l cmd (commandline -opc)
  for i in $cmd
    if test "$i" = "list" -o "$i" = "get"
      return 0
    end
  end
  return 1
end

# Scope flags for config command
# --local and --global available for all operations
complete -f -c git -n '__fish_git_gtr_using_command config' -l local -d 'Use local git config'
complete -f -c git -n '__fish_git_gtr_using_command config' -l global -d 'Use global git config'
# --system only for read operations (list, get) - write requires root
complete -f -c git -n '__fish_git_gtr_using_command config; and __fish_git_gtr_config_is_read' -l system -d 'Use system git config'
MIDDLE2

  # Config keys with descriptions (fish-specific tab-separated format)
  printf "complete -f -c git -n '__fish_git_gtr_using_command config' -a \"\n"
  local key
  for key in $CONFIG_KEYS; do
    local desc
    case "$key" in
      gtr.worktrees.dir)    desc="Worktrees base directory" ;;
      gtr.worktrees.prefix) desc="Worktree folder prefix" ;;
      gtr.defaultBranch)    desc="Default branch" ;;
      gtr.editor.default)   desc="Default editor" ;;
      gtr.editor.workspace) desc="Path to workspace file (.code-workspace)" ;;
      gtr.ai.default)       desc="Default AI tool" ;;
      gtr.provider)         desc="Hosting provider (github, gitlab)" ;;
      gtr.copy.include)     desc="Files to copy" ;;
      gtr.copy.exclude)     desc="Files to exclude" ;;
      gtr.copy.includeDirs) desc="Directories to copy (e.g., node_modules)" ;;
      gtr.copy.excludeDirs) desc="Directories to exclude" ;;
      gtr.hook.postCreate)  desc="Post-create hook" ;;
      gtr.hook.preRemove)   desc="Pre-remove hook (abort on failure)" ;;
      gtr.hook.postRemove)  desc="Post-remove hook" ;;
      gtr.hook.postCd)      desc="Post-cd hook (shell integration only)" ;;
      gtr.ui.color)         desc="Color output mode (auto, always, never)" ;;
      *)                    desc="$key" ;;
    esac
    printf "  %s\t'%s'\n" "$key" "$desc"
  done
  printf "\"\n"

  cat <<'FOOTER'

# Helper function to get branch names and special '1' for main repo
function __gtr_worktree_branches
  # Special ID for main repo
  echo '1'
  # Get branch names
  git branch --format='%(refname:short)' 2>/dev/null
end

# Complete branch names for commands that need them
complete -f -c git -n '__fish_git_gtr_using_command go' -a '(__gtr_worktree_branches)'
complete -f -c git -n '__fish_git_gtr_using_command run' -a '(__gtr_worktree_branches)'
complete -f -c git -n '__fish_git_gtr_using_command copy' -a '(__gtr_worktree_branches)'
complete -f -c git -n '__fish_git_gtr_using_command editor' -a '(__gtr_worktree_branches)'
complete -f -c git -n '__fish_git_gtr_using_command ai' -a '(__gtr_worktree_branches)'
complete -f -c git -n '__fish_git_gtr_using_command rm' -a '(__gtr_worktree_branches)'
complete -f -c git -n '__fish_git_gtr_using_command mv' -a '(__gtr_worktree_branches)'
complete -f -c git -n '__fish_git_gtr_using_command rename' -a '(__gtr_worktree_branches)'
FOOTER
}

# ── Main ─────────────────────────────────────────────────────────────────────

if [ "${1:-}" = "--check" ]; then
  tmpdir=$(mktemp -d)
  trap 'rm -rf "$tmpdir"' EXIT

  generate_bash > "$tmpdir/gtr.bash"
  generate_zsh > "$tmpdir/_git-gtr"
  generate_fish > "$tmpdir/git-gtr.fish"

  stale=0
  for file in gtr.bash _git-gtr git-gtr.fish; do
    if ! diff -q "$SCRIPT_DIR/completions/$file" "$tmpdir/$file" >/dev/null 2>&1; then
      echo "STALE: completions/$file" >&2
      diff -u "$SCRIPT_DIR/completions/$file" "$tmpdir/$file" >&2 || true
      stale=1
    fi
  done

  if [ "$stale" -eq 1 ]; then
    echo "" >&2
    echo "Run ./scripts/generate-completions.sh to update" >&2
    exit 1
  fi
  echo "All completion files are up to date"
  exit 0
fi

# Generate and write completion files
generate_bash > "$SCRIPT_DIR/completions/gtr.bash"
generate_zsh  > "$SCRIPT_DIR/completions/_git-gtr"
generate_fish > "$SCRIPT_DIR/completions/git-gtr.fish"

echo "Generated completion files:"
echo "  completions/gtr.bash"
echo "  completions/_git-gtr"
echo "  completions/git-gtr.fish"
